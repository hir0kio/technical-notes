---
description: 共有した秘密の値をもとに安全にメッセージを暗号化して送受信するためのアルゴリズム。暗号鍵を自動的に交換するラチェッティングという仕組みにより、暗号鍵が危殆化した場合に過去の通信の機密性を保ち、また危殆化した鍵がいずれ正常な鍵と交換されることで、前方秘匿性と post-compromise security を実現する。
---

# Double Ratchet アルゴリズム

共有した秘密の値をもとに安全にメッセージを暗号化して送受信するためのアルゴリズム。暗号鍵を自動的に交換するラチェッティング<sup><a href="#ref-1">1</a></sup>という仕組みにより、暗号鍵が危殆化した場合に過去の通信の機密性を保ち、また危殆化した鍵がいずれ正常な鍵と交換されることで、[前方秘匿性](https://ja.wikipedia.org/wiki/Forward_secrecy)と [post-compromise security](post-compromise-security) を実現する。

---

1. <span id="ref-1">ratchet は「爪車」（逆転止めの爪と組み合わせて、一方向だけに回転するように作られている歯車）の意。</span>

<!--
## 表記法

### ECDH(鍵ペア<sub>0</sub>, 鍵ペア<sub>1</sub>)

[楕円曲線暗号](https://ja.wikipedia.org/wiki/楕円曲線暗号)鍵ペア<sub>0</sub>の秘密鍵と鍵ペア<sub>1</sub>の公開鍵で[楕円曲線ディフィー・ヘルマン鍵共有](https://ja.wikipedia.org/wiki/楕円曲線ディフィー・ヘルマン鍵共有)を行って得られる秘密の値。

### KDF(ikm<sub>0</sub>, ikm<sub>1</sub>, ikm<sub>2</sub>, ......)

1 個以上の入力[キー マテリアル](https://csrc.nist.gov/glossary/term/keying_material) ikm<sub>0</sub>, ikm<sub>1</sub>, ikm<sub>2</sub>, ...... を連結して [HMAC-based extract-and-expand key derivation function](https://datatracker.ietf.org/doc/html/rfc5869)（HKDF）に入力して得られる出力キー マテリアルを任意の長さと数に分割して得られる対称鍵。

対称鍵 &larr; KDF(ikm)<br />
対称鍵 &larr; KDF(ikm<sub>0</sub>, ikm<sub>1</sub>, ikm<sub>2</sub>)<br />
対称鍵<sub>0</sub>, 対称鍵<sub>1</sub>, 対称鍵<sub>2</sub> &larr; KDF(ikm<sub>0</sub>, ikm<sub>1</sub>, ikm<sub>2</sub>)
-->

## 主な概念

### ラチェット

ratchet

鍵を入力すると、対応するキー マテリアルを出力して鍵を更新する[鍵導出関数](https://ja.wikipedia.org/wiki/鍵導出関数)。

- 鍵<sub>k+1</sub>, キー マテリアル<sub>k</sub> &larr; KDF(鍵<sub>k</sub>)

### 非対称ラチェット

asymmetric ratchet

自分の[ラチェット鍵](#ラチェット鍵)を更新し、[ルート鍵](#ルート鍵)、自分の新しいラチェット鍵、相手のラチェット鍵を入力すると、対応する[チェーン鍵](#チェーン鍵)を出力してルート鍵を更新する[ラチェット](#ラチェット)。

- 自分のラチェット鍵 &larr; 鍵生成()
- DH 出力 &larr; ECDH(自分のラチェット鍵, 相手のラチェット鍵)
- ルート鍵<sub>k+1</sub>, チェーン鍵<sub>k</sub> &larr; KDF(ルート鍵<sub>k</sub>, DH 出力)

### 対称ラチェット

symmetric ratchet

[チェーン鍵](#チェーン鍵)を入力すると、対応する[メッセージ鍵](#メッセージ鍵)を出力してチェーン鍵を更新する[ラチェット](#ラチェット)。

- チェーン鍵<sub>k+1</sub>, メッセージ鍵<sub>k</sub> &larr; KDF(チェーン鍵<sub>k</sub>)

### ラチェット鍵

ratchet key

[楕円曲線暗号](https://ja.wikipedia.org/wiki/楕円曲線暗号)鍵。[非対称ラチェット](#非対称ラチェット)を更新するときに新しく作成し、交換する。

### ルート鍵

root key

秘密の値。[非対称ラチェット](#非対称ラチェット)に入力し、対応する[チェーン鍵](#チェーン鍵)を導出する。[初期ハンドシェイク](#手順)で共有した値を最初のルート鍵とする。

### チェーン鍵

chain key

秘密の値。[対称ラチェット](#対称ラチェット)に入力し、対応する[メッセージ鍵](#メッセージ鍵)を導出する。

暗号化用のメッセージ鍵の導出に使うチェーン鍵は**送信チェーン鍵**、復号用のメッセージ鍵の導出に使うチェーン鍵は**受信チェーン鍵**と呼ばれる。

### メッセージ鍵

message key

メッセージを暗号化・復号するための対称鍵。[対称ラチェット](#対称ラチェット)から導出する。

それぞれのメッセージに固有であり、別のメッセージを同じメッセージ鍵で暗号化することはできない。

## 鍵のライフサイクル

| 鍵           | ライフサイクル                                                            |
| ------------ | ------------------------------------------------------------------------- |
| ラチェット鍵 | 鍵の所有者が[非対称ラチェット](#非対称ラチェット)を更新するまで。         |
| ルート鍵     | 非対称ラチェットを更新するまで。                                          |
| チェーン鍵   | 非対称ラチェットまたは[対称ラチェット](#非対称ラチェット)を更新するまで。 |
| メッセージ鍵 | メッセージの暗号化・復号に使ったら削除する。                              |

## 役割

- **Alice** は、Bob にメッセージを送る。ただし、メッセージを送るとき Bob はオフラインである場合がある。
- **Bob** は、Alice からのメッセージを受け取って Alice に返信する。ただし、返信を送るとき Alice はオフラインである場合がある。
- **サーバ** は、Alice と Bob が相手に送ったデータを一時的に保持し、相手がオンラインに復帰するとこのデータを配送する。

## 手順

[Signal プロトコル](signal-protocol)は、主に次の 3 段階から構成される。

1. **初期ハンドシェイク**。[X3DH 鍵共有プロトコル](x3dh-key-agreement-protocol)を使って[ルート鍵](double-ratchet-algorithm#ルート鍵)を共有する。
1. **[非対称ラチェット](double-ratchet-algorithm#非対称ラチェット) ステージ**。ルート鍵と Alice と Bob の[ラチェット鍵](double-ratchet-algorithm#ラチェット鍵)から対応する[チェーン鍵](double-ratchet-algorithm#チェーン鍵)を生成する。
1. **[対称ラチェット](double-ratchet-algorithm#対称ラチェット) ステージ**。チェーン鍵から対応する[メッセージ鍵](double-ratchet-algorithm#メッセージ鍵)を生成する。

Double Ratchet アルゴリズムは「**非対称ラチェット ステージ**」と「**対称ラチェット ステージ**」を担当する。

### 1. 初期ハンドシェイク

1. Alice は [X3DH 鍵合意プロトコル](x3dh-key-agreement-protocol)を使って Bob と秘密の値を共有する。この値を[ルート鍵](#ルート鍵)<sub>0</sub>とする。

### 2. Alice: Bob にメッセージを送信

Alice は Bob にメッセージを送信する。

#### 2.1. 非対称ラチェット ステージ

1. Alice は新しい[ラチェット鍵](#ラチェット鍵)を作成する。
   - Alice のラチェット鍵 &larr; 鍵生成()
1. [ルート鍵](#ルート鍵)<sub>0</sub>、自分のラチェット鍵、Bob の[前鍵](x3dh-key-agreement-protocol#前鍵)を[非対称ラチェット](#非対称ラチェット)に入力し、対応する送信[チェーン鍵](#チェーン鍵)<sub>0, 0</sub>と次のルート鍵<sub>1</sub>を得る。
   - DH 出力 &larr; ECDH(Alice のラチェット鍵, Bob の前鍵)
   - ルート鍵<sub>1</sub>, 送信チェーン鍵<sub>0, 0</sub> &larr; KDF(ルート鍵<sub>0</sub>, DH 出力)

#### 2.2. 対称ラチェット ステージ

1. 送信チェーン鍵<sub>0, 0</sub>を[対称ラチェット](#対称ラチェット)に入力し、対応する[メッセージ鍵](#メッセージ鍵)<sub>0, 0</sub>と次の送信チェーン鍵<sub>0, 1</sub>を得る。
   - 送信チェーン鍵<sub>0, 1</sub>, メッセージ鍵<sub>0, 0</sub> &larr; KDF(送信チェーン鍵<sub>0, 0</sub>)
1. メッセージ鍵<sub>0, 0</sub>で最初のメッセージを暗号化する。
1. さらにメッセージを送る場合は、
   1. 送信チェーン鍵<sub>0, 1</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>0, 1</sub>と次の送信チェーン鍵<sub>0, 2</sub>を得る。
      - 送信チェーン鍵<sub>0, 2</sub>, メッセージ鍵<sub>0, 1</sub> &larr; KDF(送信チェーン鍵<sub>0, 1</sub>)
   1. メッセージ鍵<sub>0, 1</sub>で次のメッセージを暗号化する。
   1. さらにメッセージを送る場合は、
      1. 送信チェーン鍵<sub>0, 2</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>0, 2</sub>と次の送信チェーン鍵<sub>0, 3</sub>を得る。
         - 送信チェーン鍵<sub>0, 3</sub>, メッセージ鍵<sub>0, 2</sub> &larr; KDF(送信チェーン鍵<sub>0, 2</sub>)
      1. メッセージ鍵<sub>0, 2</sub>で次のメッセージを暗号化する。
      1. ......
1. すべてのメッセージを暗号化するまで繰り返す。

---

1. 暗号化したメッセージと自分のラチェット鍵をサーバに送信する。

<!--
1. さらにメッセージを送る場合は、
   1. k=1 とする。
   1. Alice は送信チェーン鍵<sub>0, k</sub>を対称ラチェットに入力し、新しい送信チェーン鍵<sub>0, k+1</sub>とメッセージ鍵<sub>0, k</sub>を得る。<br />
      送信チェーン鍵<sub>0, k+1</sub>, メッセージ鍵<sub>0, k</sub> &larr; KDF(送信チェーン鍵<sub>0, k</sub>)
   1. メッセージ鍵<sub>0, k</sub>でメッセージを暗号化する。
   1. k &larr; k+1。
   1. すべてのメッセージを暗号化するまで繰り返す。
-->

ルート鍵またはチェーン鍵を更新したあとは、前方秘匿性のため古い鍵を削除する。

### 3. Bob: Alice からのメッセージを受信

Bob は Alice からのメッセージを受信する。

#### 3.1. 非対称ラチェット ステージ

1. Bob は Alice の暗号化されたメッセージと[ラチェット鍵](#ラチェット鍵)をサーバから受け取る。
1. [ルート鍵](#ルート鍵)<sub>0</sub>、自分の[前鍵](x3dh-key-agreement-protocol#前鍵)、Alice のラチェット鍵を[非対称ラチェット](#非対称ラチェット)に入力し、対応する受信[チェーン鍵](#チェーン鍵)<sub>0, 0</sub>と次のルート鍵<sub>1</sub>を得る。
   - DH 出力 &larr; ECDH(Bob の前鍵, Alice のラチェット鍵)
   - ルート鍵<sub>1</sub>, 受信チェーン鍵<sub>0, 0</sub> &larr; KDF(ルート鍵<sub>0</sub>, DH 出力)

#### 3.2. 対称ラチェット ステージ

1. 受信チェーン鍵<sub>0, 0</sub>を[対称ラチェット](#対称ラチェット)に入力し、対応する[メッセージ鍵](#メッセージ鍵)<sub>0, 0</sub>と次の受信チェーン鍵<sub>0, 1</sub>を得る。
   - 受信チェーン鍵<sub>0, 1</sub>, メッセージ鍵<sub>0, 0</sub> &larr; KDF(受信チェーン鍵<sub>0, 0</sub>)
1. メッセージ鍵<sub>0, 0</sub>で Alice の最初のメッセージを復号する。
1. まだ受け取ったメッセージがある場合は、
   1. 受信チェーン鍵<sub>0, 1</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>0, 1</sub>と次の受信チェーン鍵<sub>0, 2</sub>を得る。
      - 受信チェーン鍵<sub>0, 2</sub>, メッセージ鍵<sub>0, 1</sub> &larr; KDF(受信チェーン鍵<sub>0, 1</sub>)
   1. メッセージ鍵<sub>0, 1</sub>で Alice の次のメッセージを復号する。
   1. まだ受け取ったメッセージがある場合は、
      1. 受信チェーン鍵<sub>0, 2</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>0, 2</sub>と次の受信チェーン鍵<sub>0, 3</sub>を得る。
         - 受信チェーン鍵<sub>0, 3</sub>, メッセージ鍵<sub>0, 2</sub> &larr; KDF(受信チェーン鍵<sub>0, 2</sub>)
      1. メッセージ鍵<sub>0, 2</sub>で Alice の次のメッセージを復号する。
      1. ......
1. すべてのメッセージを復号するまで繰り返す。

<!--
1. さらにメッセージを受け取った場合は、
   1. k=1 とする。
   1. Bob は受信チェーン鍵<sub>0, k</sub>を対称ラチェットに入力し、新しい受信チェーン鍵<sub>0, k+1</sub>とメッセージ鍵<sub>0, k</sub>を得る。<br />
      受信チェーン鍵<sub>0, k+1</sub>, メッセージ鍵<sub>0, k</sub> &larr; KDF(受信チェーン鍵<sub>0, k</sub>)
   1. メッセージ鍵<sub>0, k</sub>で Alice のメッセージを復号する。
   1. k &larr; k+1。
   1. すべてのメッセージを復号するまで繰り返す。
-->

### 4. Bob: Alice にメッセージを送信

Alice から受け取ったメッセージに Bob が返信する。

#### 4.1. 非対称ラチェット ステージ

1. Bob は新しい[ラチェット鍵](#ラチェット鍵)を作成する。
   - Bob のラチェット鍵 &larr; 鍵生成()
1. [ルート鍵](#ルート鍵)<sub>1</sub>、自分のラチェット鍵、Alice のラチェット鍵を[非対称ラチェット](#非対称ラチェット)に入力し、対応する送信[チェーン鍵](#チェーン鍵)<sub>1, 0</sub>と次のルート鍵<sub>2</sub>を得る。
   - DH 出力' &larr; ECDH(Bob のラチェット鍵, Alice のラチェット鍵)
   - ルート鍵<sub>2</sub>, 送信チェーン鍵<sub>1, 0</sub> &larr; KDF(ルート鍵<sub>1</sub>, DH 出力')

#### 4.2. 対称ラチェット ステージ

1. 送信チェーン鍵<sub>1, 0</sub>を[対称ラチェット](#対称ラチェット)に入力し、対応する[メッセージ鍵](#メッセージ鍵)<sub>1, 0</sub>と次の送信チェーン鍵<sub>1, 1</sub>を得る。
   - 送信チェーン鍵<sub>1, 1</sub>, メッセージ鍵<sub>1, 0</sub> &larr; KDF(送信チェーン鍵<sub>1, 0</sub>)
1. メッセージ鍵<sub>1, 0</sub>で最初のメッセージを暗号化する。
1. さらにメッセージを送る場合は、
   1. 送信チェーン鍵<sub>1, 1</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>1, 1</sub>と次の送信チェーン鍵<sub>1, 2</sub>を得る。
      - 送信チェーン鍵<sub>1, 2</sub>, メッセージ鍵<sub>1, 1</sub> &larr; KDF(送信チェーン鍵<sub>1, 1</sub>)
   1. メッセージ鍵<sub>1, 1</sub>で次のメッセージを暗号化する。
   1. さらにメッセージを送る場合は、
      1. 送信チェーン鍵<sub>1, 2</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>1, 2</sub>と次の送信チェーン鍵<sub>1, 3</sub>を得る。
         - 送信チェーン鍵<sub>1, 3</sub>, メッセージ鍵<sub>1, 2</sub> &larr; KDF(送信チェーン鍵<sub>1, 2</sub>)
      1. メッセージ鍵<sub>1, 2</sub>で次のメッセージを暗号化する。
      1. ......
1. すべてのメッセージを暗号化するまで繰り返す。

---

1. 暗号化したメッセージと自分のラチェット鍵をサーバに送信する。

<!--
1. さらにメッセージを送る場合は、
   1. k=1 とする。
   1. Bob は送信チェーン鍵<sub>1, k</sub>を対称ラチェットに入力し、新しい送信チェーン鍵<sub>1, k+1</sub>とメッセージ鍵<sub>1, k</sub>を得る。<br />
      送信チェーン鍵<sub>1, k+1</sub>, メッセージ鍵<sub>1, k</sub> &larr; KDF(送信チェーン鍵<sub>1, k</sub>)
   1. メッセージ鍵<sub>1, k</sub>でメッセージを暗号化する。
   1. k &larr; k+1。
   1. すべてのメッセージを暗号化するまで繰り返す。
1. 暗号化したメッセージと自分のラチェット鍵をサーバに送信する。
-->

### 5. Alice: Bob からのメッセージを受信

Alice は Bob からの返信を受信する。

#### 5.1. 非対称ラチェット ステージ

1. Alice は Bob の暗号化されたメッセージと[ラチェット鍵](#ラチェット鍵)をサーバから受け取る。
1. [ルート鍵](#ルート鍵)<sub>1</sub>、自分のラチェット鍵、Bob のラチェット鍵を[非対称ラチェット](#非対称ラチェット)に入力し、対応する受信[チェーン鍵](#チェーン鍵)<sub>1, 0</sub>と次のルート鍵<sub>2</sub>を得る。
   - DH 出力' &larr; ECDH(Alice のラチェット鍵, Bob のラチェット鍵)
   - ルート鍵<sub>2</sub>, 受信チェーン鍵<sub>1, 0</sub> &larr; KDF(ルート鍵<sub>1</sub>, DH 出力')

#### 5.2. 対称ラチェット ステージ

1. 受信チェーン鍵<sub>1, 0</sub>を[対称ラチェット](#対称ラチェット)に入力し、対応する[メッセージ鍵](#メッセージ鍵)<sub>1, 0</sub>と次の受信チェーン鍵<sub>1, 1</sub>を得る。
   - 受信チェーン鍵<sub>1, 1</sub>, メッセージ鍵<sub>1, 0</sub> &larr; KDF(受信チェーン鍵<sub>1, 0</sub>)
1. メッセージ鍵<sub>1, 0</sub>で Bob の最初のメッセージを復号する。
1. まだ受け取ったメッセージがある場合は、
   1. 受信チェーン鍵<sub>1, 1</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>1, 1</sub>と次の受信チェーン鍵<sub>1, 2</sub>を得る。
      - 受信チェーン鍵<sub>1, 2</sub>, メッセージ鍵<sub>1, 1</sub> &larr; KDF(受信チェーン鍵<sub>1, 1</sub>)
   1. メッセージ鍵<sub>1, 1</sub>で Bob の次のメッセージを復号する。
   1. まだ受け取ったメッセージがある場合は、
      1. 受信チェーン鍵<sub>1, 2</sub>を対称ラチェットに入力し、対応するメッセージ鍵<sub>1, 2</sub>と次の受信チェーン鍵<sub>1, 3</sub>を得る。
         - 受信チェーン鍵<sub>1, 3</sub>, メッセージ鍵<sub>1, 2</sub> &larr; KDF(受信チェーン鍵<sub>1, 2</sub>)
      1. メッセージ鍵<sub>1, 2</sub>で Bob の次のメッセージを復号する。
      1. ......
1. すべてのメッセージを復号するまで繰り返す。

<!--
1. さらにメッセージを受け取った場合は、
   1. k=1 とする。
   1. Alice は受信チェーン鍵<sub>1, k</sub>を対称ラチェットに入力し、新しい受信チェーン鍵<sub>1, k+1</sub>とメッセージ鍵<sub>1, k</sub>を得る。<br />
      受信チェーン鍵<sub>1, k+1</sub>, メッセージ鍵<sub>1, k</sub> &larr; KDF(受信チェーン鍵<sub>1, k</sub>)
   1. メッセージ鍵<sub>1, k</sub>で Bob のメッセージを復号する。
   1. k &larr; k+1。
   1. すべてのメッセージを復号するまで繰り返す。
-->

## 考察

アルゴリズムの設計から、もし[ルート鍵](#ルート鍵)<sub>k</sub>が危殆化しても、鍵導出関数を reverse することができないためそれ以前のルート鍵<sub>k-1</sub>, <sub>k-2</sub>, <sub>k-3</sub>, ...... の機密性が保たれる上に、Alice と Bob の[ラチェット鍵](#ラチェット鍵)の[楕円曲線ディフィー・ヘルマン鍵共有](https://ja.wikipedia.org/wiki/楕円曲線ディフィー・ヘルマン鍵共有)が[非対称ラチェット](#非対称ラチェット)にエントロピーを与えるため、ラチェット鍵が削除されている限りその後のルート鍵<sub>k+1</sub>, <sub>k+2</sub>, <sub>k-3</sub>, ...... の機密性も保たれることがわかる。

また、それぞれのメッセージは毎回異なる[チェーン鍵](#チェーン鍵)を[対称ラチェット](#対称ラチェット)に入力して導出した固有の[メッセージ鍵](#メッセージ鍵)で暗号化されているため、（a）もしあるチェーン鍵<sub>l</sub>が危殆化してもそれ以前のメッセージ鍵<sub>l-1</sub>, <sub>l-2</sub>, <sub>l-3</sub> ...... の機密性が保たれること、（b）もしあるメッセージ鍵が危殆化してもほかのメッセージ鍵の機密性が保たれることがわかる。

## 実装

### メッセージの送信

```js
let ルート鍵;

function メッセージの送信(
  // 初めてメッセージを送るときは相手の前鍵。
  相手のラチェット鍵,

  平文メッセージ
) {
  let 暗号化済みメッセージ = [];

  // 自分のラチェット鍵を更新する。
  let 自分のラチェット鍵 = 鍵生成();

  // 非対称ラチェットを更新する。
  let DH_出力 = ECDH(自分のラチェット鍵, 相手のラチェット鍵);
  let [新しいルート鍵, 送信チェーン鍵] = KDF(ルート鍵, DH_出力);
  ルート鍵 = 新しいルート鍵;

  for (let m of 平文メッセージ) {
    // 対称ラチェットを更新する。
    let [新しい送信チェーン鍵, メッセージ鍵] = KDF(送信チェーン鍵);
    送信チェーン鍵 = 新しい送信チェーン鍵;

    // メッセージ m を暗号化する。
    暗号化済みメッセージ.push(暗号化(m, メッセージ鍵));
  }

  return {
    自分のラチェット鍵,
    暗号化済みメッセージ,
  };
}
```

### メッセージの受信

```js
let ルート鍵;

// 初めてメッセージを受け取るときは自分の前鍵。
let 自分のラチェット鍵;

function メッセージの受信(相手のラチェット鍵, 暗号化済みメッセージ) {
  let 平文メッセージ = [];

  // 非対称ラチェットを更新する。
  let DH_出力 = ECDH(自分のラチェット鍵, 相手のラチェット鍵);
  let [新しいルート鍵, 受信チェーン鍵] = KDF(ルート鍵, DH_出力);
  ルート鍵 = 新しいルート鍵;

  for (let m of 暗号化済みメッセージ) {
    // 対称ラチェットを更新する。
    let [新しい受信チェーン鍵, メッセージ鍵] = KDF(受信チェーン鍵);
    受信チェーン鍵 = 新しい受信チェーン鍵;

    // 暗号化済みメッセージ m を復号する。
    平文メッセージ.push(復号(m, メッセージ鍵));
  }

  return {
    自分のメッセージ鍵,
    平文メッセージ,
  };
}
```

## 参考文献

- M. Marlinspike, T. Perrin (2016). "The double ratchet algorithm". _Signal Foundation_. https://signal.org/docs/specifications/doubleratchet/
- Wikipedia contributors. "Double ratchet algorithm". _Wikipedia_. https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm
- K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, D. Stebila (2020). "A formal security analysis of the signal messaging protocol". _Journal of Cryptology_, 33(4), pp. 1914&ndash;1983. https://doi.org/10.1007/s00145-020-09360-1
